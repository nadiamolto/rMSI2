# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

CNormalizationsAndMeans <- function(rMSIObj_list, numOfThreads, memoryPerThreadMB, commonMassAxis) {
    .Call('_rMSI2_CNormalizationsAndMeans', PACKAGE = 'rMSI2', rMSIObj_list, numOfThreads, memoryPerThreadMB, commonMassAxis)
}

#' ParseBrukerXML.
#'
#' Reads a Bruker's xml file exported using fleximaging.
#' A list is returned where each element in the list is named according the ROI name.
#' Each element in the list consists in a data.frame with the pixels XY coordinates inside each ROI.
#'
#' @param xml_path the full path where XML file is stored.
#'
#' @return ROI pixel coordinates arranged in a named list.
#' 
CparseBrukerXML <- function(xml_path) {
    .Call('_rMSI2_CparseBrukerXML', PACKAGE = 'rMSI2', xml_path)
}

#' Generic method for the imzMLreader
#' testingimzMLBinRead
#' @param ibdFname: full path to the ibd file.
#' @param NPixels: Total number of pixels in the image.
#' @param N: number of elemetns (or data point to read).
#' @param offset: offset in bytes at which the reading operation is started.
#' @param read_mz: if true m/z data is readed, otherwise intensities are readed.
#' @param continuous: true if imzML data is in continuous mode
NULL

#' Testing the imzMLwriter in sequential mode
#' This function creates a new ibd file with the provided data descibed in the following params
#' @param ibdFname: full path to the ibd file.
#' @param mz_dataTypeString: String to specify the data format used to encode m/z values.
#' @param int_dataTypeString: String to specify the data format used to encode intensity values.
#' @param uuid: 16 bytes long UUID.
#' @param mzArray: A matrix with the m/z values for all pixels. Each pixel corresponds to a row. If there is only one row data will be saved in continuous mode
#' @param intArray: A matrix with the intensity values for all pixels. Each pixel corresponds to a row so the number of pixels is extracted from here.
.debug_imzMLBinWriterSequential <- function(ibdFname, mz_dataTypeString, int_dataTypeString, str_uuid, mzArray, intArray) {
    .Call('_rMSI2_testingimzMLBinWriteSequential', PACKAGE = 'rMSI2', ibdFname, mz_dataTypeString, int_dataTypeString, str_uuid, mzArray, intArray)
}

#' CimzMLBinCreateNewIBD.
#' This function creates a new ibd file with the provided uuid
#' @param ibdFname: full path to the ibd file.
#' @param uuid: 16 bytes long UUID.
CimzMLBinCreateNewIBD <- function(ibdFname, str_uuid) {
    invisible(.Call('_rMSI2_CimzMLBinCreateNewIBD', PACKAGE = 'rMSI2', ibdFname, str_uuid))
}

#' CimzMLBinAppendMass.
#' This function appends a new mass axis to a given ibd file.
#' The last added offset is returned.
#' @param ibdFname: full path to the ibd file.
#' @param mz_dataTypeString:  String to specify the data format used to encode m/z values.
#' @param mzNew: The mass axis to append.
CimzMLBinAppendMass <- function(ibdFname, mz_dataTypeString, mzNew) {
    .Call('_rMSI2_CimzMLBinAppendMass', PACKAGE = 'rMSI2', ibdFname, mz_dataTypeString, mzNew)
}

#' CimzMLBinAppendIntensity.
#' This function appends a new mass axis to a given ibd file.
#' The last added offset is returned.
#' @param ibdFname: full path to the ibd file.
#' @param int_dataTypeString:  String to specify the data format used to encode m/z values.
#' @param intNew: The mass axis to append.
CimzMLBinAppendIntensity <- function(ibdFname, int_dataTypeString, intNew) {
    .Call('_rMSI2_CimzMLBinAppendIntensity', PACKAGE = 'rMSI2', ibdFname, int_dataTypeString, intNew)
}

#' A method to use the imzMLwriter in modify mode to allow direct modification of mass axes for the calibration
#' This function modifies data of an ibd file with the following params
#' @param ibdFname: full path to the ibd file.
#' @param NPixels: Total number of pixels in the image.
#' @param mz_dataTypeString: String to specify the data format used to encode m/z values.
#' @param int_dataTypeString: String to specify the data format used to encode intensity values.
#' @param continuous: true if imzML data is in continuous mode
#' @param mzNew: A vector with the m/z values. Must be the same length as the original imzML mass target massa axis.
#' @param mzOffset: offset in the ibd file of the target mass axis.
CimzMLBinWriteModifyMass <- function(ibdFname, NPixels, mz_dataTypeString, int_dataTypeString, continuous, mzNew, mzOffset) {
    invisible(.Call('_rMSI2_CimzMLBinWriteModifyMass', PACKAGE = 'rMSI2', ibdFname, NPixels, mz_dataTypeString, int_dataTypeString, continuous, mzNew, mzOffset))
}

#' CimzMLBinReadMass.
#' 
#' Reads a single mass axis from the imzML file.
#' 
#' @param ibdFname: full path to the ibd file.
#' @param NPixels: Total number of pixels in the image.
#' @param N: number of elemetns (or data point to read).
#' @param offset: offset in bytes at which the reading operation is started.
#' @param continuous: true if imzML data is in continuous mode
CimzMLBinReadMass <- function(ibdFname, NPixels, N, offset, dataTypeString, continuous) {
    .Call('_rMSI2_CimzMLBinReadMass', PACKAGE = 'rMSI2', ibdFname, NPixels, N, offset, dataTypeString, continuous)
}

#' CimzMLBinReadIntensity.
#' 
#' Reads a single mass axis from the imzML file.
#' 
#' @param ibdFname: full path to the ibd file.
#' @param NPixels: Total number of pixels in the image.
#' @param N: number of elemetns (or data point to read).
#' @param offset: offset in bytes at which the reading operation is started.
#' @param continuous: true if imzML data is in continuous mode
CimzMLBinReadIntensity <- function(ibdFname, NPixels, N, offset, dataTypeString, continuous) {
    .Call('_rMSI2_CimzMLBinReadIntensity', PACKAGE = 'rMSI2', ibdFname, NPixels, N, offset, dataTypeString, continuous)
}

#' Method to read a peak list from an imzML file. Processed mode is assumed.
#' testingimzMLBinRead
#' @param ibdFname: full path to the ibd file.
#' @param imzML_peakList_descriptor: imzML file description as it is returned by the CimzMLParse() function.
#' @param PixelID: the pixel ID to read a peak list.
CimzMLReadPeakList <- function(ibdFname, imzML_peakList_descriptor, PixelID) {
    .Call('_rMSI2_CimzMLReadPeakList', PACKAGE = 'rMSI2', ibdFname, imzML_peakList_descriptor, PixelID)
}

#' Method to overwrite the UUID of an imzML ibd file.
#' testingimzMLBinRead
#' @param ibdFname: full path to the ibd file.
#' @param newUUID: the new uuid as a string.
overwriteIbdUUid <- function(ibdFname, newUUID) {
    invisible(.Call('_rMSI2_overwriteIbdUUid', PACKAGE = 'rMSI2', ibdFname, newUUID))
}

#' Cload_imzMLSpectra
#' Load spectra into a Matrix object interpolating to the common mass axis when necessary.
#' @param rMSIobj: an rMSI object prefilled with a parsed imzML.
#' @param pixelIDs: pixel ID's of the spectra to load in C-style indexing (starting at 0).
#' @param commonMassAxis: a common mass axis that may be different than the mass axis in the rMSI object.
#' @param number_of_threads: number of thread to use during interpolation
Cload_imzMLSpectra <- function(rMSIobj, pixelIDs, commonMassAxis, number_of_threads) {
    .Call('_rMSI2_Cload_imzMLSpectra', PACKAGE = 'rMSI2', rMSIobj, pixelIDs, commonMassAxis, number_of_threads)
}

CimzMLParse <- function(xml_path) {
    .Call('_rMSI2_CimzMLParse', PACKAGE = 'rMSI2', xml_path)
}

CimzMLStore <- function(fname, imgInfo, mass_spectrometer_file_format = "rMSI exported imzML") {
    .Call('_rMSI2_CimzMLStore', PACKAGE = 'rMSI2', fname, imgInfo, mass_spectrometer_file_format)
}

AlignSpectrumToReference <- function(mass, ref, spectrumInterpolated, massProcessedMode, intensityProcessedMode, bilinear = FALSE, lagRefLow = 0.1, lagRefMid = 0.5, lagRefHigh = 0.9, iterations = 1L, lagLimitppm = 200, fftOverSampling = 10L, winSizeRelative = 0.6) {
    .Call('_rMSI2_AlignSpectrumToReference', PACKAGE = 'rMSI2', mass, ref, spectrumInterpolated, massProcessedMode, intensityProcessedMode, bilinear, lagRefLow, lagRefMid, lagRefHigh, iterations, lagLimitppm, fftOverSampling, winSizeRelative)
}

#' MergeMassAxisAutoBinSize.
#' 
#' Merges two mass axis in a single one using an apropiate bin size without having to specify the bin sizes.
#' The resulting mass axis will display a bin size equal to the minimum of two supplied vectors. 
#' The bin size is calculated relative to the m/z for better accuracy.
#' The resulting mass axis range is calculated using the common range between the two mass axis.
#' If there is no overlao between the two mass axis range an error will be raised.
#' 
#' @param mz1 the first mass axis to merge.
#' @param mz2 the second mass axis to merge.
#' 
#' @return a list containing the common mass axis that represents mz1 and mz1 accurately and a boolean indicating if and error was raised.
#' 
MergeMassAxisAutoBinSize <- function(mz1, mz2) {
    .Call('_rMSI2_MergeMassAxisAutoBinSize', PACKAGE = 'rMSI2', mz1, mz2)
}

COverallAverageSpectrum <- function(rMSIObj_list, numOfThreads, memoryPerThreadMB, commonMassAxis, minTIC, maxTic) {
    .Call('_rMSI2_COverallAverageSpectrum', PACKAGE = 'rMSI2', rMSIObj_list, numOfThreads, memoryPerThreadMB, commonMassAxis, minTIC, maxTic)
}

#' MergeMassAxis.
#' 
#' Merges two mass axis in a single one using an apropiate bin size.
#' The resulting mass axis will display a bin size equal to the minimum of two supplied vectors. 
#' The bin size must be supplied along each input mass axis.
#' The first mass axis (mz1) can be a zero-length vector.
#' 
#' @param mz1 the first mass axis to merge.
#' @param mz2 the second mass axis to merge.
#' 
#' @return the common mass axis that represents mz1 and mz1 accurately.
#' 
NULL

CcommonMassAxis <- function(rMSIObj_list, numOfThreads, memoryPerThreadMB) {
    .Call('_rMSI2_CcommonMassAxis', PACKAGE = 'rMSI2', rMSIObj_list, numOfThreads, memoryPerThreadMB)
}

CRunFillPeaks <- function(rMSIObj_list, numOfThreads, memoryPerThreadMB, preProcessingParams, commonMassAxis, peakMatrix) {
    invisible(.Call('_rMSI2_CRunFillPeaks', PACKAGE = 'rMSI2', rMSIObj_list, numOfThreads, memoryPerThreadMB, preProcessingParams, commonMassAxis, peakMatrix))
}

CInternalReferenceSpectrum <- function(rMSIObj_list, numOfThreads, memoryPerThreadMB, referenceSpectrum, commonMassAxis) {
    .Call('_rMSI2_CInternalReferenceSpectrum', PACKAGE = 'rMSI2', rMSIObj_list, numOfThreads, memoryPerThreadMB, referenceSpectrum, commonMassAxis)
}

CRunPeakPicking <- function(rMSIObj_list, numOfThreads, memoryPerThreadMB, preProcessingParams, uuid, outputDataPath, imzMLoutFnames, commonMassAxis) {
    .Call('_rMSI2_CRunPeakPicking', PACKAGE = 'rMSI2', rMSIObj_list, numOfThreads, memoryPerThreadMB, preProcessingParams, uuid, outputDataPath, imzMLoutFnames, commonMassAxis)
}

CRunPreProcessing <- function(rMSIObj_list, numOfThreads, memoryPerThreadMB, preProcessingParams, reference, uuid, outputDataPath, imzMLoutFnames, commonMassAxis) {
    .Call('_rMSI2_CRunPreProcessing', PACKAGE = 'rMSI2', rMSIObj_list, numOfThreads, memoryPerThreadMB, preProcessingParams, reference, uuid, outputDataPath, imzMLoutFnames, commonMassAxis)
}

#' NoiseEstimationFFTCosWin.
#' 
#' Estimate the noise of a spectrum using a FFT filter and a cosinus window in frequency domain.
#' 
#' @param x an Rcpp::NumericVector containing the spectrum intensities.
#' @param filWinSize an integer specified the cosinus win size in samples.
#' 
#' @return an Rcpp::NumericVector containing the estimated noise.
#' @export
NoiseEstimationFFTCosWin <- function(x, filWinSize = 40L) {
    .Call('_rMSI2_NoiseEstimationFFTCosWin', PACKAGE = 'rMSI2', x, filWinSize)
}

#' NoiseEstimationFFTExpWin.
#' 
#' Estimate the noise of a spectrum using a FFT filter and a decay exponential window in frequency domain.
#' 
#' @param x an Rcpp::NumericVector containing the spectrum intensities.
#' @param filWinSize an integer specified the cosinus win size in samples.
#' 
#' @return an Rcpp::NumericVector containing the estimated noise.
#' @export
NoiseEstimationFFTExpWin <- function(x, filWinSize = 40L) {
    .Call('_rMSI2_NoiseEstimationFFTExpWin', PACKAGE = 'rMSI2', x, filWinSize)
}

#' NoiseEstimationFFTCosWinMat.
#' 
#' Estimate the noise of some spectra using a FFT filter and a cosinus window in frequency domain.
#' 
#' @param x an Rcpp::NumericMatrix containing the spectra intensities. Each spectrum in a row.
#' @param filWinSize an integer specified the cosinus win size in samples.
#' 
#' @return an Rcpp::NumericMatrix containing the estimated noise in a matrix where each spectrum is a row.
#' @export
NoiseEstimationFFTCosWinMat <- function(x, filWinSize = 40L) {
    .Call('_rMSI2_NoiseEstimationFFTCosWinMat', PACKAGE = 'rMSI2', x, filWinSize)
}

#' NoiseEstimationFFTExpWinMat.
#' 
#' Estimate the noise of some spectra using a FFT filter and a decay exponential window in frequency domain.
#' 
#' @param x an Rcpp::NumericMatrix containing the spectra intensities. Each spectrum in a row.
#' @param filWinSize an integer specified the cosinus win size in samples.
#' 
#' @return an Rcpp::NumericMatrix containing the estimated noise in a matrix where each spectrum is a row.
#' @export
NoiseEstimationFFTExpWinMat <- function(x, filWinSize = 40L) {
    .Call('_rMSI2_NoiseEstimationFFTExpWinMat', PACKAGE = 'rMSI2', x, filWinSize)
}

C_adductAnnotation <- function(numMonoiso, numAdducts, tolerance, numMass, R_monoisitopeMassVector, R_adductMassVector, R_isotopes, R_isotopeListOrder, R_massAxis, R_peakMatrix, numPixels, R_labelAxis, R_monoisotopicIndexVector) {
    .Call('_rMSI2_C_adductAnnotation', PACKAGE = 'rMSI2', numMonoiso, numAdducts, tolerance, numMass, R_monoisitopeMassVector, R_adductMassVector, R_isotopes, R_isotopeListOrder, R_massAxis, R_peakMatrix, numPixels, R_labelAxis, R_monoisotopicIndexVector)
}

C_isotopeAnnotator <- function(massPeaks, massChannels, numPixels, numIso, PeakMtx, massVec, massChanVec, tolerance, scoreThreshold, ToleranceInScans, charge) {
    .Call('_rMSI2_C_isotopeAnnotator', PACKAGE = 'rMSI2', massPeaks, massChannels, numPixels, numIso, PeakMtx, massVec, massChanVec, tolerance, scoreThreshold, ToleranceInScans, charge)
}

CRunPeakBinning <- function(rMSIObj_list, numOfThreads, memoryPerThreadMB, preProcessingParams) {
    .Call('_rMSI2_CRunPeakBinning', PACKAGE = 'rMSI2', rMSIObj_list, numOfThreads, memoryPerThreadMB, preProcessingParams)
}

#' DetectPeaks_C.
#' 
#' Detect peaks from a Rcpp::NumericVector object and returns data in a R matrix.
#' This method is only exported to be use by R function DetectPeaks which is an actual R function.
#' The returned peak positions follows C indexing style, this is starts with zero.
#' 
#' @param mass a NumericVector containing the mass axis of the spectrum.
#' @param intensity a NumericVector where peaks must be detected.
#' @param SNR Only peaks with an equal or higher SNR are retained.
#' @param WinSize The windows used to detect peaks and caculate noise.
#' @param UpSampling the oversampling used for acurate mass detection and area integration.
#' 
#' @return a NumerixMatrix of 5 rows corresponding to: mass, intensity of the peak, SNR, area and binSize.
#' 
DetectPeaks_C <- function(mass, intensity, SNR = 5, WinSize = 20L, UpSampling = 10L) {
    .Call('_rMSI2_DetectPeaks_C', PACKAGE = 'rMSI2', mass, intensity, SNR, WinSize, UpSampling)
}

#' TestPeakInterpolation_C.
#' 
#' 
#' @param mass a NumericVector containing the mass axis of the spectrum.
#' @param intensity a NumericVector where peaks must be detected.
#' @param peakIndex the location of the peak to interpolate in the spectrum.  
#' @param WinSize The windows used to detect peaks and caculate noise.
#' @param UpSampling the oversampling used for acurate mass detection and area integration.
#' @param useHanning if hanning windowing must be used befor interpolation.
#' @param Iterations number of iterations to perform. This is just for testing interpolation efficiency
#' 
#' @return a NumerixVector with the FFT interpolated peak shape.
#' 
TestPeakInterpolation_C <- function(mass, intensity, peakIndex, WinSize = 20L, UpSampling = 10L, useHanning = FALSE, Iterations = 1L) {
    .Call('_rMSI2_TestPeakInterpolation_C', PACKAGE = 'rMSI2', mass, intensity, peakIndex, WinSize, UpSampling, useHanning, Iterations)
}

#' TestHanningWindow.
#' 
#' Method to test the implementation of Hanning window in R session.
#' @param mass a NumericVector containing the mass axis of the spectrum.
#' @param WinSize The windows used to detect peaks and caculate noise.
#' @param UpSampling the oversampling used for acurate mass detection and area integration.
#' 
#' @return a NumericVector containing the Hanning Window.
#' 
TestHanningWindow <- function(mass, WinSize = 20L, UpSampling = 10L) {
    .Call('_rMSI2_TestHanningWindow', PACKAGE = 'rMSI2', mass, WinSize, UpSampling)
}

#' TestAreaWindow.
#' 
#' Method to test the implementation of Area window in R session.
#' @param mass a NumericVector containing the mass axis of the spectrum.
#' @param WinSize The windows used to detect peaks and caculate noise.
#' @param UpSampling the oversampling used for acurate mass detection and area integration.
#' 
#' @return a NumericVector containing the Area Window.
#' 
TestAreaWindow <- function(mass, WinSize = 20L, UpSampling = 10L) {
    .Call('_rMSI2_TestAreaWindow', PACKAGE = 'rMSI2', mass, WinSize, UpSampling)
}

ReduceDataPointsC <- function(mass, intensity, massMin, massMax, npoints) {
    .Call('_rMSI2_ReduceDataPointsC', PACKAGE = 'rMSI2', mass, intensity, massMin, massMax, npoints)
}

#' decodePngStream2IonImages.
#'
#' Obtain a multiple mass channel ion image by decoding the hdd img stream at a specified ionIndex.
#' The MAX operator will be used to merge all ion images in a single image matrix.
#'
#' @param ionIndex the index of ion to extract from the img stream. C style indexing, starting with zero.
#' @param ionCount number of ion image to decode.
#' @param normalization_coefs a vector containing the intensy normalization coeficients.
#' 
#' @return A NumerixMatrix containing the ion image.
#' 
NULL

#' Ccreate_rMSIXBinData.
#' 
#' creates new rMSIXBin files (.XrMSI and .BrMSI). Previous files will be deleted.
#'
#' @param rMSIobj: an rMSI object prefilled with a parsed imzML.
#' @param number_of_threads: number of threads used for imgStream encoding.
#' @return the rMSI object with rMSIXBin inforation completed. 
Ccreate_rMSIXBinData <- function(rMSIobj, number_of_threads) {
    .Call('_rMSI2_Ccreate_rMSIXBinData', PACKAGE = 'rMSI2', rMSIobj, number_of_threads)
}

#' Cload_rMSIXBinData.
#' 
#' Loads the data from the rMSIXBin files (.XrMSI and .BrMSI).
#' This method is used to load a previously stored rMSIXBin file.
#'
#' @param path: full path to the .XrMSI file.
#' @param fname: file name of the .XrMSI file without the extension.
#' @return the rMSI object with rMSIXBin inforation completed. 
Cload_rMSIXBinData <- function(path, fname) {
    .Call('_rMSI2_Cload_rMSIXBinData', PACKAGE = 'rMSI2', path, fname)
}

#' Cload_rMSIXBinIonImage.
#' 
#' loads a ion image from the .BrNSI img stream.
#' 
#' @param rMSIobj: an rMSI object prefilled with a parsed imzML.
#' @param ionIndex: the first mass channel at which the image starts.
#' @param ionCount: the numer of mass channels used to construct the ion image (a.k.a. image tolerance window).
#' @param normalization_coefs a vector containing the intensy normalization coeficients.
#' @param number_of_threads: number of threads used for imgStream encoding.
#' 
#' @return the ion image as a NumericMatrix using max operator with all the ion images of the mass channels. 
Cload_rMSIXBinIonImage <- function(rMSIobj, ionIndex, ionCount, normalization_coefs, number_of_threads) {
    .Call('_rMSI2_Cload_rMSIXBinIonImage', PACKAGE = 'rMSI2', rMSIobj, ionIndex, ionCount, normalization_coefs, number_of_threads)
}

#' Smoothing_SavitzkyGolay.
#' 
#' Computes the Savitzky-Golay smoothing of a vector x using a filter size of sgSize.
#' @param x the data vector to smooth.
#' @param sgSize valid values are: 5, 7, 9, 11, 13, 15.
#' @return the smoothed data vector.
Smoothing_SavitzkyGolay <- function(x, sgSize = 5L) {
    .Call('_rMSI2_Smoothing_SavitzkyGolay', PACKAGE = 'rMSI2', x, sgSize)
}

